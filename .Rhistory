if (is.null(starting_point) & !is.element(0, nsize)){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & is.element(0, nsize))){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
starting_point
if (is.null(starting_point) & !is.element(0, nsize)){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & is.element(0, nsize))){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
julia_eval("starting_point")
if (is.null(starting_point) & !is.element(0, nsize)){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & is.element(0, nsize))){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
starting_point
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
# Calculo de x, y
julia_assign("mu", mu)
julia_assign("sigma", sigma)
x <- julia_eval("x = calculo_xy(mu, sigma)[1]")
x <- julia_eval("x = 0.5")
y <- julia_eval("y = 0.5")
if (is.null(starting_point) & !is.element(0, nsize)){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & is.element(0, nsize))){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
nsize
tiene_ceros = F
nsize <- c(9, 18, 24)
zsize <- c(3, 4, 5)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
# Calculo de x, y
julia_assign("mu", mu)
julia_assign("sigma", sigma)
x <- julia_eval("x = calculo_xy(mu, sigma)[1]")
y <- julia_eval("y = calculo_xy(mu, sigma)[2]")
if (is.null(starting_point) & tiene_ceros = F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros = T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
nsize
zsize
zsize <- c(10, 20, 30)
nsize <- c(100, 200, 300)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
# Calculo de x, y
julia_assign("mu", mu)
julia_assign("sigma", sigma)
x <- julia_eval("x = calculo_xy(mu, sigma)[1]")
y <- julia_eval("y = calculo_xy(mu, sigma)[2]")
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
is.null(starting_point) & tiene_ceros == F
starting_point = NULL
nsize
nsize <- c(100, 200, 300)
zsize <- c(10, 20, 30)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
# Calculo de x, y
julia_assign("mu", mu)
julia_assign("sigma", sigma)
x <- julia_eval("x = calculo_xy(mu, sigma)[1]")
y <- julia_eval("y = calculo_xy(mu, sigma)[2]")
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
zsize
nsize
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
?JuliaObject
julia_eval("zsize ./ nsize")
zsize
nsize
nsize <- c(100, 200, 300)
zsize <- c(50, 100, 150)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
starting_point <- NULL
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
zsizw
zsize
nsize
starting_point <- NULL
zsize <- c(100, 200, 300)
nsize <- c(50, 100, 150)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
nsize
zsize
nsize <- c(100, 200, 300)
zsize <- c(50, 100, 150)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
nsize
zsize
julia_assign("nsize", zsize)
julia_assign("zsize", zsize)
julia_eval("nsize")
julia_eval("zsize")
nsize <- c(100, 200, 300)
zsize <- c(50, 100, 150)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", nsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
starting_point <- NULL
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
starting_point <- NULL
nsize <- c(0, 100, 150)
zsize <- c(7, 0, 100)
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", nsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
nsize
zsize
nsize <- c(0, 100, 150)
zsize <- c(7, 0, 100)
starting_point <- NULL
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
nsize
zsize
julia_assign("nsize", nsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point & tiene_ceros == T)){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
nsize <- c(0, 100, 150)
zsize <- c(7, 0, 100)
starting_point <- NULL
tiene_ceros <- is.element(0, nsize)
nsize <- JuliaObject(nsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
julia_assign("nsize", nsize)
julia_assign("zsize", zsize)
if (is.null(starting_point) & tiene_ceros == F){
starting_point <- julia_eval("starting_point = [x, y, zsize ./ nsize]")
} else {
if (is.null(starting_point) & tiene_ceros == T){
starting_point <- julia_eval("starting_point = [x, y, 0, 0, 0]")
}
}
# Convertimos el starting point a JuliaObject
starting_point <- JuliaObject(starting_point)
julia_assign("starting_point", starting_point)
starting_point
nsize <- c(0, 5)
zsize <- c(1, 2)
tiene_ceros <- is.element(0, nsize) | is.element(0, zsize)
zsize <- c(1, 0)
tiene_ceros <- is.element(0, nsize) | is.element(0, zsize)
nsize <- c(1, 5)
zsize <- c(1, 0)
tiene_ceros <- is.element(0, nsize) | is.element(0, zsize)
zsize <- c(1, 3)
tiene_ceros <- is.element(0, nsize) | is.element(0, zsize)
message("Punto inicial no válido")
Sys.setenv(JULIA_NUM_THREADS = "4")
library("JuliaCall")
julia <- julia_setup(JULIA_HOME = "C:/Users/Valeria/AppData/Local/Programs/Julia 1.5.3/bin") #Debería correr sin problema
julia_library("Random")
julia_library("Plots")
julia_library("Turing")
julia_library("Distributions")
julia_library("StatsPlots")
julia_library("DataFrames")
julia_library("MCMCChains")
library(tidyverse)
library(dplyr)
library(HDInterval)
library(purrr)
delta <- 0.8       #sensitividad
gamma <- 0.995     #especificidad
julia_eval("Threads.nthreads()")
zsize <- c(100, 200, 300)
zsize <- JuliaObject(zsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
julia_assign("zsize", zsize)
mu_p_gamma = 0.5
sigma_p_gamma = 1/12
# Calculo de x_p_gamma, y_p_gamma
julia_assign("mu_p_gamma", mu_p_gamma)
julia_assign("sigma_p_gamma", sigma_p_gamma)
x_p_gamma <- julia_eval("x_p_gamma = calculo_xy(mu_p_gamma, sigma_p_gamma)[1]")
paste0("sim       = gammapoissoncero(",zsize,",",x_p_gamma,",", y_p_gamma, ")")
x_p_gamma <- 0.5
y_p_gamma <- 1/12
paste0("sim       = gammapoissoncero(",zsize,",",x_p_gamma,",", y_p_gamma, ")")
burnin = 50000
niter = 100000
nchains = 4
paste0("hmcsample = sample(sim, HMC(0.01, 5), MCMCThreads(), burnin = ",
burnin, ", ", niter, ", ", nchains, ")")
s1 <- c(9, 10, 11)
s2 <- c(1, 2, 3)
s3 <- c(1, 1, 1)
s4 <- c(0, 15, 24)
s5 <- c(9, 8, 8)
nsize <- c(1, 1, 1)
tiene_ceros <- (is.element(0, nsize) | is.element(0, s1)
| is.element(0, s2) | is.element(0, s3) |
is.element(0, s4))
tiene_ceros
s4 <- c(9, 9, 9)
tiene_ceros <- (is.element(0, nsize) | is.element(0, s1)
| is.element(0, s2) | is.element(0, s3) |
is.element(0, s4))
paste0("sim       = betabinomialcinco(",nsize,",",s1,",", s2, ",", s3, ",", s4, ",", s5, ",",
x_p1,",", y_p1,",", x_p2,",", y_p2, ",", x_p3,",", y_p3, ",", x_p4,",", y_p4, ",", x_p5,",", y_p5, ",",
delta,",", gamma,")")
x_p1 = x_p2 = x_p3 = x_p4 = x_p5
x_p1 = x_p2 = x_p3 = x_p4 = x_p5 = 0.5
y_p1 = y_p2 = y_p3 = y_p4 = y_p5 = 1/12
delta
paste0("sim       = betabinomialcinco(",nsize,",",s1,",", s2, ",", s3, ",", s4, ",", s5, ",",
x_p1,",", y_p1,",", x_p2,",", y_p2, ",", x_p3,",", y_p3, ",", x_p4,",", y_p4, ",", x_p5,",", y_p5, ",",
delta,",", gamma,")")
zsize <- c(1, 2, 3)
zsize <- JuliaObject(zsize) # para los 3. Si no, ponle el transpuesto
zsize
Sys.setenv(JULIA_NUM_THREADS = "8")
julia <- JuliaCall::julia_setup("/julia-1.5.4/bin")
Sys.setenv(JULIA_NUM_THREADS = "4")
library("JuliaCall")
julia <- julia_setup(JULIA_HOME = "C:/Users/Valeria/AppData/Local/Programs/Julia 1.5.3/bin") #Debería correr sin problema
julia_library("Turing")
julia_library("Distributions")
julia_library("DataFrames")
julia_library("StatsPlots")
library(tidyverse)
library(dplyr)
library(HDInterval)
if (exists("check.packages") && check.packages){
julia_install_package_if_needed("Random")
julia_install_package_if_needed("Plots")
julia_install_package_if_needed("Turing")
julia_install_package_if_needed("Distributions")
julia_install_package_if_needed("StatsPlots")
julia_install_package_if_needed("DataFrames")
julia_install_package_if_needed("MCMCChains")
}
julia_library("Random")
julia_library("Plots")
julia_library("Turing")
julia_library("Distributions")
julia_library("StatsPlots")
julia_library("DataFrames")
julia_library("MCMCChains")
delta <- 0.8       #sensitividad
gamma <- 0.995     #especificida
#función para hacer el ajuste de sensitividad y especificidad
ajuste_sens <- function(x, delta = 1, gamma = 1){
return(delta*x + (1 - gamma)*(1 - x))
}
check_sum <- function(x){
suma = sum(x)
if (suma != 1){
x <- x / suma
}
return(x)
}
paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,",",")")
k <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 3)
k
alpha = 1
beta = 1
tau = 1
mu = 0
compilar_julia = T
burnin = 5000
niter = 10000
nchains = 4
proba_nom = str_remove(as.character(runif(1)),"\\.")
# Carga los metodos que tiene que cargar
if (compilar_julia){
julia_eval('include("functions/Model/lognormal.jl")')
julia_eval('include("functions/Model/check_convergencia.jl")')
}
setwd("~/GitHub/EPCOVID_v2/functions/Model")
# Carga los metodos que tiene que cargar
if (compilar_julia){
julia_eval('include("functions/Model/lognormal.jl")')
julia_eval('include("functions/Model/check_convergencia.jl")')
}
setwd("~/GitHub/EPCOVID_v2/functions/Model")
# Carga los metodos que tiene que cargar
if (compilar_julia){
julia_eval('include("functions/Model/lognormal.jl")')
julia_eval('include("functions/Model/check_convergencia.jl")')
}
setwd("~/GitHub/EPCOVID_v2")
# Carga los metodos que tiene que cargar
if (compilar_julia){
julia_eval('include("functions/Model/lognormal.jl")')
julia_eval('include("functions/Model/check_convergencia.jl")')
}
k <- JuliaObject(k)
julia_assign("k", k)
# Asigacion de parametros
julia_assign("alpha", alpha)
julia_assign("beta", beta)
julia_assign("tau", tau)
julia_assign("mu", mu)
julia_assign("proba_nom", proba_nom)
julia_eval("proba_nom = string(proba_nom)")
burnin <- format(burnin, scientific = F)
niter <- format(niter, scientific = F)
julia_assign("niter", niter)
julia_assign("burnin", burnin)
julia_assign("nchains", nchains)
# Aquí solo le estás diciendo "oye guardame en sim el método multinomial_cero con estas variables"
julia_eval(paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,",",")"))
zsize <- c(1, 2, 3)
x_p_gamma = 1/3
y_p_gamma = 0
compilar_julia = T
burnin = 50000
niter = 100000
nchains = 4
burnin = 5000
niter = 10000
# Carga los metodos que tiene que cargar
if (compilar_julia){
julia_eval('include("functions/Model/gammapoissoncero.jl")')
julia_eval('include("functions/Model/check_convergencia.jl")')
}
zsize <- JuliaObject(zsize) #OJO AQUI, tiene que decir "Julia Object of type Array{Float64,1}"
julia_assign("zsize", zsize)
# Calculo de x_p_gamma, y_p_gamma
julia_assign("x_p_gamma", x_p_gamma)
julia_assign("y_p_gamma", y_p_gamma)
julia_assign("proba_nom", proba_nom)
julia_eval("proba_nom = string(proba_nom)")
burnin <- format(burnin, scientific = F)
niter <- format(niter, scientific = F)
julia_assign("niter", niter)
julia_assign("burnin", burnin)
julia_assign("nchains", nchains)
# Aquí solo le estás diciendo "oye guardame en sim el método multinomial_cero con estas variables"
julia_eval(paste0("sim       = gammapoissoncero(",zsize,",",x_p_gamma,",", y_p_gamma, ")"))
# Aquí es cuando ya corres las simulaciones como lo hice yo
julia_eval(paste0("hmcsample = sample(sim, HMC(0.01, 5), MCMCThreads(), burnin = ",
burnin, ", ", niter, ", ", nchains, ")"))
# Aquí solo le estás diciendo "oye guardame en sim el método multinomial_cero con estas variables"
julia_eval(paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,",",")"))
paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,",",")")
paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,")")
# Aquí solo le estás diciendo "oye guardame en sim el método multinomial_cero con estas variables"
julia_eval(paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,")"))
paste0("sim       = lognormal(",k,",",alpha,",", beta,
tau,",", mu,")")
alpha
beta
paste0("sim       = lognormal(",k,",",alpha,",", beta, ",",
tau,",", mu,")")
# Aquí solo le estás diciendo "oye guardame en sim el método multinomial_cero con estas variables"
julia_eval(paste0("sim       = lognormal(",k,",",alpha,",", beta, ",",
tau,",", mu,")"))
# Aquí es cuando ya corres las simulaciones como lo hice yo
julia_eval(paste0("hmcsample = sample(sim, HMC(0.01, 5), MCMCThreads(), burnin = ",
burnin, ", ", niter, ", ", nchains, ")"))
# En caso de no convergencia:
# Paso 1. Checar que tus n's estén bien (neta, checalo)
# Paso 2. Aumentar el número de iteraciones
# Paso 3. Si solamente falla la estacionariedad, checa las gráficas y ve donde está fallando
julia_eval(paste0("check_convergencia(hmcsample, ", niter, ", ", burnin, ", ", nchains, ", proba_nom)"))
